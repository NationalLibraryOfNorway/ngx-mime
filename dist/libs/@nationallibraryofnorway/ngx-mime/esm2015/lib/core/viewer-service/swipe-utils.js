import { Side } from '../models/side';
import { Direction } from '../models/direction';
import { ViewerOptions } from '../models/viewer-options';
export class SwipeUtils {
    // Added threshold to prevent sensitive direction-calculation when zoomed in
    static getSwipeDirection(start, end, useThreshold) {
        let deltaX = Math.abs(start.x - end.x);
        const deltaY = Math.abs(start.y - end.y);
        deltaX = useThreshold
            ? deltaX - ViewerOptions.pan.swipeDirectionThreshold
            : deltaX;
        if (start.x > end.x && deltaX >= deltaY) {
            return Direction.LEFT;
        }
        else if (start.x < end.x && deltaX >= deltaY) {
            return Direction.RIGHT;
        }
        else {
            return Direction.UNDEFINED;
        }
    }
    static getSideIfPanningPastEndOfCanvasGroup(canvasGroupRect, vpBounds) {
        if (this.isPanningOutsideLeft(canvasGroupRect, vpBounds)) {
            return Side.LEFT;
        }
        else if (this.isPanningOutsideRight(canvasGroupRect, vpBounds)) {
            return Side.RIGHT;
        }
        else {
            return null;
        }
    }
    static isPanningOutsideCanvasGroup(canvasGroupRect, vpBounds) {
        return (this.isPanningOutsideLeft(canvasGroupRect, vpBounds) ||
            this.isPanningOutsideRight(canvasGroupRect, vpBounds));
    }
    static isPanningOutsideLeft(canvasGroupRect, vpBounds) {
        return vpBounds.x < canvasGroupRect.x;
    }
    static isPanningOutsideRight(canvasGroupRect, vpBounds) {
        return (vpBounds.x + vpBounds.width > canvasGroupRect.x + canvasGroupRect.width);
    }
    /**
     *
     * @param direction Current computed direction, expressed as an
     * angle counterclockwise relative to the positive X axis (-pi to pi, in radians).
     * Only valid if speed > 0.
     */
    static isDirectionInRightSemicircle(direction) {
        return direction > -Math.PI / 2 && direction < Math.PI / 2;
    }
    /**
     * @param direction @see isDirectionInRightSemicircle
     */
    static isDirectionInLeftSemicircle(direction) {
        return !this.isDirectionInRightSemicircle(direction) || direction === 0; // fix for speed = 0
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3dpcGUtdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9saWJzL25neC1taW1lL3NyYy9saWIvY29yZS92aWV3ZXItc2VydmljZS9zd2lwZS11dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDdEMsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ2hELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUN6RCxNQUFNLE9BQU8sVUFBVTtJQUNyQiw0RUFBNEU7SUFDNUUsTUFBTSxDQUFDLGlCQUFpQixDQUN0QixLQUFZLEVBQ1osR0FBVSxFQUNWLFlBQXNCO1FBRXRCLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdkMsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN6QyxNQUFNLEdBQUcsWUFBWTtZQUNuQixDQUFDLENBQUMsTUFBTSxHQUFHLGFBQWEsQ0FBQyxHQUFHLENBQUMsdUJBQXVCO1lBQ3BELENBQUMsQ0FBQyxNQUFNLENBQUM7UUFFWCxJQUFJLEtBQUssQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsSUFBSSxNQUFNLElBQUksTUFBTSxFQUFFO1lBQ3ZDLE9BQU8sU0FBUyxDQUFDLElBQUksQ0FBQztTQUN2QjthQUFNLElBQUksS0FBSyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxJQUFJLE1BQU0sSUFBSSxNQUFNLEVBQUU7WUFDOUMsT0FBTyxTQUFTLENBQUMsS0FBSyxDQUFDO1NBQ3hCO2FBQU07WUFDTCxPQUFPLFNBQVMsQ0FBQyxTQUFTLENBQUM7U0FDNUI7SUFDSCxDQUFDO0lBRUQsTUFBTSxDQUFDLG9DQUFvQyxDQUN6QyxlQUFxQixFQUNyQixRQUFjO1FBRWQsSUFBSSxJQUFJLENBQUMsb0JBQW9CLENBQUMsZUFBZSxFQUFFLFFBQVEsQ0FBQyxFQUFFO1lBQ3hELE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztTQUNsQjthQUFNLElBQUksSUFBSSxDQUFDLHFCQUFxQixDQUFDLGVBQWUsRUFBRSxRQUFRLENBQUMsRUFBRTtZQUNoRSxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7U0FDbkI7YUFBTTtZQUNMLE9BQU8sSUFBSSxDQUFDO1NBQ2I7SUFDSCxDQUFDO0lBRUQsTUFBTSxDQUFDLDJCQUEyQixDQUNoQyxlQUFxQixFQUNyQixRQUFjO1FBRWQsT0FBTyxDQUNMLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxlQUFlLEVBQUUsUUFBUSxDQUFDO1lBQ3BELElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxlQUFlLEVBQUUsUUFBUSxDQUFDLENBQ3RELENBQUM7SUFDSixDQUFDO0lBRUQsTUFBTSxDQUFDLG9CQUFvQixDQUFDLGVBQXFCLEVBQUUsUUFBYztRQUMvRCxPQUFPLFFBQVEsQ0FBQyxDQUFDLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBRUQsTUFBTSxDQUFDLHFCQUFxQixDQUFDLGVBQXFCLEVBQUUsUUFBYztRQUNoRSxPQUFPLENBQ0wsUUFBUSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxHQUFHLGVBQWUsQ0FBQyxDQUFDLEdBQUcsZUFBZSxDQUFDLEtBQUssQ0FDeEUsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILE1BQU0sQ0FBQyw0QkFBNEIsQ0FBQyxTQUFpQjtRQUNuRCxPQUFPLFNBQVMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUM3RCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxNQUFNLENBQUMsMkJBQTJCLENBQUMsU0FBaUI7UUFDbEQsT0FBTyxDQUFDLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxTQUFTLENBQUMsSUFBSSxTQUFTLEtBQUssQ0FBQyxDQUFDLENBQUMsb0JBQW9CO0lBQy9GLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlY3QgfSBmcm9tICcuLi9tb2RlbHMvcmVjdCc7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uL21vZGVscy9wb2ludCc7XG5pbXBvcnQgeyBTaWRlIH0gZnJvbSAnLi4vbW9kZWxzL3NpZGUnO1xuaW1wb3J0IHsgRGlyZWN0aW9uIH0gZnJvbSAnLi4vbW9kZWxzL2RpcmVjdGlvbic7XG5pbXBvcnQgeyBWaWV3ZXJPcHRpb25zIH0gZnJvbSAnLi4vbW9kZWxzL3ZpZXdlci1vcHRpb25zJztcbmV4cG9ydCBjbGFzcyBTd2lwZVV0aWxzIHtcbiAgLy8gQWRkZWQgdGhyZXNob2xkIHRvIHByZXZlbnQgc2Vuc2l0aXZlIGRpcmVjdGlvbi1jYWxjdWxhdGlvbiB3aGVuIHpvb21lZCBpblxuICBzdGF0aWMgZ2V0U3dpcGVEaXJlY3Rpb24oXG4gICAgc3RhcnQ6IFBvaW50LFxuICAgIGVuZDogUG9pbnQsXG4gICAgdXNlVGhyZXNob2xkPzogYm9vbGVhblxuICApOiBEaXJlY3Rpb24ge1xuICAgIGxldCBkZWx0YVggPSBNYXRoLmFicyhzdGFydC54IC0gZW5kLngpO1xuICAgIGNvbnN0IGRlbHRhWSA9IE1hdGguYWJzKHN0YXJ0LnkgLSBlbmQueSk7XG4gICAgZGVsdGFYID0gdXNlVGhyZXNob2xkXG4gICAgICA/IGRlbHRhWCAtIFZpZXdlck9wdGlvbnMucGFuLnN3aXBlRGlyZWN0aW9uVGhyZXNob2xkXG4gICAgICA6IGRlbHRhWDtcblxuICAgIGlmIChzdGFydC54ID4gZW5kLnggJiYgZGVsdGFYID49IGRlbHRhWSkge1xuICAgICAgcmV0dXJuIERpcmVjdGlvbi5MRUZUO1xuICAgIH0gZWxzZSBpZiAoc3RhcnQueCA8IGVuZC54ICYmIGRlbHRhWCA+PSBkZWx0YVkpIHtcbiAgICAgIHJldHVybiBEaXJlY3Rpb24uUklHSFQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBEaXJlY3Rpb24uVU5ERUZJTkVEO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXRTaWRlSWZQYW5uaW5nUGFzdEVuZE9mQ2FudmFzR3JvdXAoXG4gICAgY2FudmFzR3JvdXBSZWN0OiBSZWN0LFxuICAgIHZwQm91bmRzOiBSZWN0XG4gICk6IFNpZGUgfCBudWxsIHtcbiAgICBpZiAodGhpcy5pc1Bhbm5pbmdPdXRzaWRlTGVmdChjYW52YXNHcm91cFJlY3QsIHZwQm91bmRzKSkge1xuICAgICAgcmV0dXJuIFNpZGUuTEVGVDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNQYW5uaW5nT3V0c2lkZVJpZ2h0KGNhbnZhc0dyb3VwUmVjdCwgdnBCb3VuZHMpKSB7XG4gICAgICByZXR1cm4gU2lkZS5SSUdIVDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGlzUGFubmluZ091dHNpZGVDYW52YXNHcm91cChcbiAgICBjYW52YXNHcm91cFJlY3Q6IFJlY3QsXG4gICAgdnBCb3VuZHM6IFJlY3RcbiAgKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuaXNQYW5uaW5nT3V0c2lkZUxlZnQoY2FudmFzR3JvdXBSZWN0LCB2cEJvdW5kcykgfHxcbiAgICAgIHRoaXMuaXNQYW5uaW5nT3V0c2lkZVJpZ2h0KGNhbnZhc0dyb3VwUmVjdCwgdnBCb3VuZHMpXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyBpc1Bhbm5pbmdPdXRzaWRlTGVmdChjYW52YXNHcm91cFJlY3Q6IFJlY3QsIHZwQm91bmRzOiBSZWN0KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHZwQm91bmRzLnggPCBjYW52YXNHcm91cFJlY3QueDtcbiAgfVxuXG4gIHN0YXRpYyBpc1Bhbm5pbmdPdXRzaWRlUmlnaHQoY2FudmFzR3JvdXBSZWN0OiBSZWN0LCB2cEJvdW5kczogUmVjdCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICB2cEJvdW5kcy54ICsgdnBCb3VuZHMud2lkdGggPiBjYW52YXNHcm91cFJlY3QueCArIGNhbnZhc0dyb3VwUmVjdC53aWR0aFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGRpcmVjdGlvbiBDdXJyZW50IGNvbXB1dGVkIGRpcmVjdGlvbiwgZXhwcmVzc2VkIGFzIGFuXG4gICAqIGFuZ2xlIGNvdW50ZXJjbG9ja3dpc2UgcmVsYXRpdmUgdG8gdGhlIHBvc2l0aXZlIFggYXhpcyAoLXBpIHRvIHBpLCBpbiByYWRpYW5zKS5cbiAgICogT25seSB2YWxpZCBpZiBzcGVlZCA+IDAuXG4gICAqL1xuICBzdGF0aWMgaXNEaXJlY3Rpb25JblJpZ2h0U2VtaWNpcmNsZShkaXJlY3Rpb246IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBkaXJlY3Rpb24gPiAtTWF0aC5QSSAvIDIgJiYgZGlyZWN0aW9uIDwgTWF0aC5QSSAvIDI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGRpcmVjdGlvbiBAc2VlIGlzRGlyZWN0aW9uSW5SaWdodFNlbWljaXJjbGVcbiAgICovXG4gIHN0YXRpYyBpc0RpcmVjdGlvbkluTGVmdFNlbWljaXJjbGUoZGlyZWN0aW9uOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMuaXNEaXJlY3Rpb25JblJpZ2h0U2VtaWNpcmNsZShkaXJlY3Rpb24pIHx8IGRpcmVjdGlvbiA9PT0gMDsgLy8gZml4IGZvciBzcGVlZCA9IDBcbiAgfVxufVxuIl19